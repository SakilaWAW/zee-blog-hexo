---
layout: post
title: "排序算法[上]"
date: 2020-02-11 17:15:11 +0800
categories: 数据结构与算法
banner_img: /images/sort-part-one-banner.jpg
index_img: /images/sort-part-one-banner.jpg
tags: 算法
---

这篇文章是算法系列的第一篇，为什么写这么个系列呢，主要因为我一直对算法这个东西很好奇，非常想学，只有总结才能让我更好的系统学习，不然就是狗熊掰棒子 🙃，而且顺便能给其他同学一点点儿启发也是非常开心的一件事儿。我所有的文章都会以一种讲述的口吻来写，讲给大家听也讲给自己听。好了废话不多说，下面直接进入主题。

## 概览

排序算法这个东西相信很多同学从很早就开始接触了，最开始是冒泡排序(万年入门排序)，之后再深入一些我们会了解到更多: 选择、插入、希尔、归并、快排、堆排等等，我们一一道来(假设所有的排序都是从小到大)。

## 如何判断一个算法好坏

稍微了解下我们就会发现排序算法多种多样，那么我们怎么判断他们的好坏呢？几个概念应运而生:

### 时间复杂度

快慢是衡量一个算法最最直观的方法了，我们可以直接在运行程序前后计时，得出程序的运行时间进行比较，但是有的时候我们手头没有计算机来运行程序，我们就需要一些理论知识来判断程序好坏，时间复杂度就是衡量程序快慢的一个指标，通常是人脑可以推算出来的。

当输入为 N 时，我们可以大概估出一个时间量级，我们称之为`O(..)`，当我们考虑时间复杂度的时候，通常会忽略倍数，因为在 N 比较大的时候倍数并不会影响结果，比如`O(N^2)`和`O(3N^2)`，当 N 为 100 时，常数 3 对结果影响已经没不大了，更不用说样本更大的时候了。

常见的复杂度有`O(1)`,`O(N)`,`O(N^2)`,`O(N^logN)`(出现 log 是因为二分处理情况)。

### 空间复杂度

占用空间大小是另一个衡量因素，这个复杂度的意思是在样本量级为 N 的时候，程序会占用多少内存，这个指标太高也是不行的。空间复杂度也用`O(..)`表示，比如我们在算法中声明了个长度为 N 的数组来进行中间的数据处理，这时算法的空间复杂度就是`O(N)`。

### 稳定性

上面两个复杂度对算法都是通用的，对于排序来说还有稳定性这个指标，他是指当我们排完序之后值相同的项顺序还是否都是原来的顺序，如果是的话算法就是稳定的，否则就是不稳定。

有些时候我们在排序的过程中不想让相同值的项再改变顺序，比如：

> 一个队列每一项有两个属性 A，B，我们希望整体以 A 属性的大小进行排序，但当 A 相同时我们以 B 的大小来进行排序。

如果我们的排序算法是稳定的，那么我们可以以 B 属性大小进行排列，然后再以 A 属性大小排序。两次排序达到要求。但是如果我们的算法是不稳定的，在第二次排序的时候可能会破坏第一次的结果。

综上我们也要考虑到排序算法的稳定性。

## 排序算法实现

排序算法里选择排序、冒泡排序、插入排序、希尔排序都属于初级排序算法，相对来说效率不高，真正常用的是快排、归并排序、堆排和他们的一些变型。非常推荐在阅读文章时看看[排序算法的动画演示](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html)，除了堆排序之外都有，堆排序在[这里](https://www.cs.usfca.edu/~galles/visualization/HeapSort.html)。阅读的时候边看动画演示边看下面的代码可以让你更好的理解。

### 冒泡排序

我们从最基本的冒泡排序开始，我们这么做：1-2 比出个较大的，把较大的放到第 2 个，然后 2-3 比，较大的放在第 3 个...以此类推，遍历一轮之后我们可以获得整个数组最大的值，且时候最大的值已经被换到最后一个了。这时第一轮结束，从头遍历开始第二轮。

这种方式我们可以把它联想为一个个气泡从水底冒到水面的过程，所以称之为冒泡排序，代码实现如下:

```javascript
const mock = [3, 5, 6, 2, 6, 1, 2, 2, 4];

function bubbleSort(arr) {
  for (let i = arr.length; i > 0; --i) {
    for (let j = 0; j < i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        // 交换
        let temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  return arr;
}
console.log(`排序后结果: ${bubbleSort(mock)}`);
```

我们从上面的三个维度分析一下，我们遍历了 N 遍数组，数组中有 N 个元素，所以时间复杂度就是`O(N^2)`。(其实从第二遍起就是 N-1 了，后面越来越少，但是这种细小的次数可以忽略不计，计做 N 次)。空间复杂度上由于我们交换元素时需要有个临时变量，所以是`O(1)`。最后从稳定性上讲，如果是我上面的实现来看是稳定的，因为当两数相同时并不进行交换，如果比较的时候用`>=`算法就是不稳定的了。

可见冒泡虽然实现起来简单，但是效率确实不高。

### 选择排序

选择排序思想比冒泡还简单：遍历数组，选择一个最小的，换到第一个位置，遍历第二遍时从第二个开始选出剩下的里面最小的，换到第二个位置...以此类推。思想比较简单，直接上代码：

```javascript
function selectSort(arr) {
  let minIdx;
  for (let i = 0; i < arr.length; ++i) {
    minIdx = i;
    for (let j = i + 1; j < arr.length; ++j) {
      if (arr[j] < arr[minIdx]) minIdx = j;
    }
    // 交换i 和 minIdx 的数据
    let temp = arr[i];
    arr[i] = arr[minIdx];
    arr[minIdx] = temp;
  }
  return arr;
}
```

显而易见，时间复杂度还是`O(N^2)`，空间复杂度也是`O(1)`，另外选择排序是不稳定的，举个例子:`[3,2,3,1,5]`，在第一遍的时候第一个 3 和 1 交换，已经破坏了排序的稳定性。

选择排序符合一般人的第一想法，但是奈何效率不高还不稳定。

### 插入排序

当我们斗地主抽牌的时候，我们往往一张一张抽，把抽到的牌插到已有手牌的合适位置，这就是插入排序的思想。下面我们来实现一下：

```javascript
function insertSort(arr) {
  let target = 0,
    nextIdx = 0;
  for (let i = 1; i < arr.length; ++i) {
    target = arr[i];
    nextIdx = i - 1;
    while (nextIdx >= 0 && arr[nextIdx] > target) {
      arr[nextIdx + 1] = arr[nextIdx];
      --nextIdx;
    }
    arr[nextIdx + 1] = target;
  }
  return arr;
}
```

插入排序的时间复杂度也是`O(n^2)`，空间复杂度也是`O(1)`，它是一种稳定的排序。看起来和前面的两种一样低效，不过它在特定情况下比前面两种情况快得多，试想下如果数组中绝大部分的数字都已经排好序，时间复杂度会是如何？这是我们发现在向前寻找位置的时候几乎不用遍历，这时候的复杂度趋近`O(N)`，非常高效。

总体来说插入排序虽在一般情况下效率不高(但也强于前两种)，但是在特殊情况下还是可以派上用场的。

### 希尔排序

人们发现插入排序在数据基本排好序的时候效率极高，那么有人就说了我们能不能大概先给数据排个序，然后再用插入排序？希尔排序就这么产生了。

由于插入排序只能相邻的元素移动，所以如果有个元素要从数组结尾移动到数组开头就很耗费时间，希尔排序提出一个概念：如果数组中任意间隔为 h 的数据都是有序的，则称这个数组为`h有序数组`，当 h 为 1 的时候，数组就排好序了。这样在 h 很大的时候，即使要移动距离很远也可以很快的移动过去，我们多排几遍，让 h 慢慢变小最终变为 1，每次排序都用插入排序，数组越来越有序，排序的性能也越来越高，下面看看代码：

```javascript
function shellSort(arr) {
  let h = 1;
  while (h < arr.length / 3) h = 3 * h + 1;
  while (h >= 1) {
    let target = 0,
      nextIdx = 0;
    for (let i = h; i < arr.length; i += h) {
      target = arr[i];
      nextIdx = i - h;
      while (nextIdx >= 0 && arr[nextIdx] > target) {
        arr[nextIdx + h] = arr[nextIdx];
        nextIdx -= h;
      }
      arr[nextIdx + h] = target;
    }
    h = Math.floor(h / 3);
  }
  return arr;
}
```

明显能看出来，希尔排序的写法是基于插入排序的，我这里 h 的设置方法是比较常用的。希尔排序是个很神奇的排序，因为他仅仅比插入排序多加了个`h有序数组`的概念，性能就可以达到插入排序的很多倍。至今专家们也没找到一个 h 数列使性能最大化，但是无论如何都是比插入排序快很多的，小于`O(N^2)`，空间复杂度上来讲还是`O(1)`，唯一比插入排序差的就是它不稳定。

总结一下，希尔排序在插入排序的基础上大大优化了性能，虽然比不上快排、堆排等算法，但胜在编写简单，性能可接受。(虽然还是用不上)

## 总结

以上便是冒泡、选择、插入、希尔的基本思想和简单实现，这几种排序都被称为初级排序算法，效率并不高，在`排序算法[下]`中我们将深入了解几种高级算法，敬请期待...
